*Hard*

## Description

There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be $O(log (m+n))$.

You may assume **nums1** and **nums2** cannot be both empty.

**Example 1:**

```
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
```

**Example 2:**

```
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```

---

## Intuition

Find the median of two sorted arrays. If possible, the simplest solution is Merge Sort which has $O(m+n)$ time complexity.

In the description, it indicates it may have a solution based on Binary Search.

> The overall run time complexity should be $O(log (m+n))$.



## Solution 1: Merge Sort

Set two indexes, `i` in `nums1` and  `j` in `nums2`. Compare the `nums1[i]` with `nums2[j]` , add the smaller one to a new array.

The new array only costs at most $(m+n)/2+1$ units of space since we only need to merge sort before the median. And, we do the merge sort for  $count = (m+n)/2+1$ times.

According to the parity of $m+n$, calculate the median in different ways:

- If $m+n$ is odd, the last element of new arrays (`nums[count-1]`) is exactly the median.
- If $m+n$ is even, the median is the average of last two elements.

Don't forget the **boundary conditions** when either of `nums1` or `nums2` is empty, and when `i` or `j` reaches the end of each array.

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<int> nums(m+n);
        int i = 0, j = 0;
        int count = 0;
        if(m == 0){
            return n % 2 == 0 ? ((double)nums2[n/2 - 1]+(double)nums2[n/2])/2 : nums2[n/2];
        }
        if(n == 0){
            return m % 2 == 0 ? ((double)nums1[m/2 - 1]+(double)nums1[m/2])/2 : nums1[m/2];
        }
        while(count  < (m+n)/2 + 1){
            if(i >= m)nums[count] = nums2[j++];
            else if(j >= n)nums[count] = nums1[i++];
            else if(nums1[i] < nums2[j]) nums[count] = nums1[i++];
            else nums[count] = nums2[j++];
            count++;
        }
        if((m+n) % 2 == 0)
            return ((double)nums[count - 1]+(double)nums[count - 2])/2;
        else 
            return nums[count-1];
        return 0;
    }
};
```

Time complexity: $O(m+n)$, not in line with the question.

The code is not terse, neither. QAQ



## Solution 2: Binary

